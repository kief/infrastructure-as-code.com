:source-highlighter: pygments

= Pattern: Template Stack

A great benefit of defining infrastructure as code is that it's easy to replicate infrastructure. This has a variety of uses, including:

- High availability (provision a new instance of infrastructure on demand in order to fail over to it),
- Scalability (provision additional instances of infrastructure in different locations),
- Multiple customers (provision an additional instance of an essentially identical service for each customer),
- Consistency (provision a replica of production in order to deploy and test software),
- Testability (provision and test an instance of infrastructure after making a change to the code, before applying it to production environments).

In all of these cases, it is very useful to define an [infrastructure stack](README.adoc) so that it can be used to manage multiple, highly consistent instances. A stack defined this way is a Template Stack.

This pattern is similar to the [library stack pattern](library-stack.adoc), in which a single stack definition is used to create multiple instances. However, instances of a library stack are normally extended and customized for different purposes, while instances of a template stack are intended to be very consistent.

So a defining characteristic of the template stack pattern is that there is very little variation between each instance of the stack. Therefore, implementations of this pattern should aim to minimize the scope for variance.

Variance between stack instances is enabled by the use of [stack parameters](../stack-parameter/README.adoc). The stack definition specifies a number of parameters which can be set. For each stack instance, values are passed for these parameters, which the definition uses to custoomize the instance.

Typically, parameters are used to define names and IDs to distinguish the elements of each instance from one another. This is particularly useful to avoid clashes between instances of infrastructure. For example, it may not be possible to create more than one subnet called `myAppSubnet`, so it would be useful to have a parameter named `INSTANCE_NAME`, and use this to name the subnet `myAppSubnet-${INSTANCE_NAME}`.

Parameters may also be used to vary sizing, for example creating different minimum and maximum cluster sizes, or different size servers.

In cases where there is greater variation between instances of a stack, either the template stack may not be the appropriate pattern, or else more thought may be needed to adhere to the pattern and keep a clean architecture. As a rule, the parameters used to define differences between stack instances should be very simple - a string, number, or in some cases lists. Additionally, there should not be significant changes to the code that is applied based on the value of a parameter.

It is a red flag when a parameter is used as a conditional that decides whether to create large chunks of infrastructure. An example would be a parameter that indicates whether or not to provision a database cluster. If some instances require a database, and some do not, it may be preferable to split the database cluster into its own stack. The decision is then taken at a higher level of which stacks to provision. This keeps each stack simple, and easier to test.


== Alternative approaches

Some teams use the [singleton stack anti-pattern](singleton-stack.adoc) to manage multiple instances of a stack. This involves creating a new copy of the stack definition code for each new environment or other instance. While this is a straightforward approach to implement, it makes it difficult to keep each instance consistent.

A variation of the singleton stack is the [wrapper stack pattern](wrapper-stack.adoc). Each stack instance has a separate definition. However, the bulk of the infrastructure code is contained in a [stack module](stack-module.adoc), a library which is imported into the stack definition. This way the code is declared once - in the module - and re-used across each stack instance. Each stack definition is effectively used as a mechanism to define parameter values for its stack instance. 


== Testing stack definitions

When making changes to an infrastructure stack definition, being able to provision a test instance enables you to test your changes before applying them to your production stack instance. As an individual engineer making changes to infrastructure code, you can provision and test your changes on your own sandbox instance before committing changes. As a team, you can use [Continuous Integration](https://martinfowler.com/articles/continuousIntegration.html) and [Continuous Delivery](https://martinfowler.com/bliki/ContinuousDelivery.html) to facilitate a consistent and reliable process for testing and delivering changes to your infrastructure. There are a number of considerations for [testing infrastructure changes](../stack-testing/README.adoc) effectively.


== Managing consistent test environments

For infrastructure that is used to run software developed by other teams, using the same stack definition to create instances for various test and review environments (e.g. "dev", "qa", "staging", "preprod", "uat", etc.) ensures that any given build of the software is running on a production-like environment. Delivering software and infrastructure changes through [pipelines](../stack-pipelines) can make change management and release processes easier, faster, more reliable, and more compliant.

